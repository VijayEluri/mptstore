<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
                      
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
    <title>MPTStore RDF Storage Engine</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>

<div class="toc">
    <h1>
      <img src="rdf-icon.png"/>
      MPTStore @mptstore.version@
    </h1>
    <div class="tocbox">
        
    <ol>
		<li><a href="#intro">What is MPTStore?</a></li>
		<li><a href="#diff">How does it differ from existing approaches?</a></li>
		<li><a href="#inst">Downloading and Installing</a></li>
		<li><a href="#api">API Documentation</a></li>
		<li><a href="#issues">Known Issues / Bugs</a></li>
		<li><a href="#license">License Information</a></li>
    </ol>
    </div>
</div>

<div class="sec2">
  <h2><a name="intro">1. What is MPTStore?</a></h2>
  <p>
    MPTStore is a Java library for projects that need persistent, 
    transaction-capable storage and querying of very large quantities 
    of RDF data.
  </p>
  <p>
    The primary areas of focus are scalability and transaction
    safety with simple query support.  Complex query support
    (a subset of SPARQL features) is in development and looks
    very promising.  Out of scope features include reasoning 
    (inference) and quads.
  </p>
  <p>
    MPTStore is implemented as a lightweight layer on top of JDBC.
    It was developed and tested using Postgres as the underlying
    database, but can be easily adapted to work with other RDBMS 
    engines.
  </p>
</div>

<div class="sec2">
  <h2><a name="diff">2. How does it differ from existing approaches?</a></h2>
  <p>
The traditional way of storing RDF in a relational database
is to use a "big table of triples".  Variations on this basic 
approach are employed by popular RDF storage engines including 
<a href="http://jena.sourceforge.net/">Jena</a>, 
<a href="http://www.openrdf.org/">Sesame</a>,
and <a href="http://sourceforge.net/projects/threestore/">3store</a>.
  </p>
  <p>
Our approach, MPT ("Mapped Predicate Tables"),
is different.  Recognizing that the number of
relationship types in real RDF data is much
lower than the number of nodes, MPT distributes
triples across several tables, each holding all
the relationships of a certain type.  This offers
an obvious opportunity to scale across multiple
storage devices.  
  </p>
  <p>
Although we have initially focused on supporting
simple queries, we believe that the efficiency
of query plans for complex RDF queries can be
much higher with MPT than with the "big table
of triples" approach.
  </p>
</div>


<div class="sec2">
  <h2><a name="inst">2. Downloading and Installing</a></h2>
  <p>
    The latest distribution (source and binary) can be downloaded from
    <a href="http://www.sf.net/projects/mptstore">http://www.sf.net/projects/mptstore</a>
  </p>
  <p>
    Note: The binary distribution is compiled for Java 1.5.
  </p>
</div>

<div class="sec2">
  <h2><a name="api">3. API Documentation</a></h2>
<p>
  See the <a href="api/index.html">API Javadocs</a> 
  for more detailed information.
</p>
</div>

<div class="sec2">
  <h2><a name="issues">5. Known Issues / Bugs</a></h2>
  <ul>
  <li>
    Lack of validation for RDF strings.
    RDF nodes are represented within the API and in 
    the database as N-Triple strings, without unicode
    ("\u") escaping.  
  </li>
  <li>
    Blank nodes are not supported.
  </li>
  <li>
    Literal values are not normalized.  Applications should take
    care to pre-normalize the value part of the literal before
    adding it, if normalization is required.
  </li>
  <li>
    Unbound predicate queries are relatively slow when the graph
    contains statements using many distinct predicates.
    In the future, this might be addressed in one of the following ways:
    <ol>
      <li> Storage of every triple in a complete triple
           table in addition to the predicate-specific tables.
           This would increase storage requirements 2x to 3x.
           In addition, update throughput would be reduced
           to at least half to a third.  Portions of queries
           with unbound predicates would use this table,
           while bound predicate portions would still get
           the performance benefit of going against the
           predicate-specific tables.
      </li>
      <li> In an environment where overhead of a complete triple 
           table is not desired, another option is to parallelize the 
           queries on each table.
           In the general case, this requires a connection per
           execution thread and thus, consistency would
           be difficult to enforce at the database level
           using transactions.  One solution to this problem
           is to block writes while the necessary group of 
           reading connections are beginning their transactions.
      </li>
      <li>
        Another idea is to have something like a complete triple table,
        except it would contain references to predicates (not the actual
        text), and references to the row# in the predicate for each triple.
        This information could be used to know the exact subset of 
        predicate tables that need to be queried to form the list of
        triples for a particular subject.
        Call this the "S,P,row" approach.  The advantage over #1
        would be reduced storage space.  The disadvantage would be
        more overhead for updates.
      </li>
    </ol>
  </li>
  </ul>
</div>

<div class="sec2">
  <h2><a name="license">6. License Information</a></h2>
  <p>
MPTStore is distributed under the Educational Community License (ECL), v1.0.  
</p>
<p>
The distribution also includes several third-party, open-source libraries, each with
it's own license terms.
</p>
<p>
See the <a href="license/index.html">License Information Page</a> for specific terms of
all relevant licenses.
  </p>
</div>

<div id="footer">
    <div id="copyright">
      Copyright &#xA9; 2006, Cornell University
    </div>

    <div id="lastModified">
      Last Modified <script type="text/javascript">
      //<![CDATA[
            var cvsDate = "$Date: 2006/05/01 01:11:27 $";
            var parts = cvsDate.split(" ");
            var modifiedDate = parts[1];
            document.write(modifiedDate);
      //]]>
      </script>
    </div>
</div>
</body>
</html>
